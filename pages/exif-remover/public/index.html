<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EXIF Cleaner — Strip Metadata</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Darker+Grotesque:wght@400;600;800;900&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
      :root {
        --ink: #0a0a0b;
        --paper: #f5f2eb;
        --paper-dim: #e8e4db;
        --vermillion: #e63b2e;
        --vermillion-glow: rgba(230, 59, 46, 0.3);
        --charcoal: #1a1a1c;
        --smoke: #2d2d30;
        --ash: #6b6b70;
        --silver: #9a9a9f;
        --success: #2e7d32;
        --success-dim: rgba(46, 125, 50, 0.15);

        --font-display: 'Darker Grotesque', sans-serif;
        --font-mono: 'DM Mono', monospace;

        --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
        --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        font-size: 16px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      body {
        font-family: var(--font-display);
        background: var(--ink);
        color: var(--paper);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow-x: hidden;
      }

      /* Film grain overlay */
      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.035;
        z-index: 1000;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      }

      /* Halftone pattern background */
      .bg-pattern {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.03;
        background-image: radial-gradient(circle, var(--paper) 1px, transparent 1px);
        background-size: 24px 24px;
      }

      .container {
        width: 100%;
        max-width: 440px;
        margin: 0 auto;
        padding: 32px 20px;
        display: flex;
        flex-direction: column;
        gap: 32px;
        position: relative;
        z-index: 1;
      }

      /* Header */
      .header {
        text-align: left;
        padding-bottom: 24px;
        border-bottom: 1px solid var(--smoke);
      }

      .logo {
        font-family: var(--font-display);
        font-size: 2.8rem;
        font-weight: 900;
        letter-spacing: -0.03em;
        line-height: 1;
        margin-bottom: 12px;
        display: flex;
        align-items: baseline;
        gap: 8px;
      }

      .logo-main {
        color: var(--paper);
      }

      .logo-accent {
        color: var(--vermillion);
        font-size: 0.5em;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        transform: translateY(-4px);
        display: inline-block;
      }

      .tagline {
        font-family: var(--font-mono);
        font-size: 0.75rem;
        color: var(--silver);
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      /* Main upload card */
      .card {
        background: var(--charcoal);
        border: 1px solid var(--smoke);
        position: relative;
      }

      /* Corner accents on card */
      .card::before,
      .card::after {
        content: '';
        position: absolute;
        width: 24px;
        height: 24px;
        border-color: var(--vermillion);
        border-style: solid;
        opacity: 0.6;
        transition: opacity 0.3s ease;
      }

      .card::before {
        top: -1px;
        left: -1px;
        border-width: 2px 0 0 2px;
      }

      .card::after {
        bottom: -1px;
        right: -1px;
        border-width: 0 2px 2px 0;
      }

      .card:hover::before,
      .card:hover::after {
        opacity: 1;
      }

      /* Upload area - styled like a developing tray */
      .upload-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 240px;
        padding: 40px 32px;
        cursor: pointer;
        transition: all 0.4s var(--ease-out-expo);
        position: relative;
        overflow: hidden;
      }

      /* Animated border effect */
      .upload-area::before {
        content: '';
        position: absolute;
        inset: 16px;
        border: 1px dashed var(--ash);
        transition: all 0.4s var(--ease-out-expo);
      }

      .upload-area:hover::before,
      .upload-area.dragging::before {
        border-color: var(--vermillion);
        border-style: solid;
        inset: 12px;
      }

      .upload-area.dragging {
        background: rgba(230, 59, 46, 0.05);
      }

      .upload-icon {
        width: 64px;
        height: 64px;
        margin-bottom: 24px;
        position: relative;
      }

      .upload-icon svg {
        width: 100%;
        height: 100%;
        stroke: var(--silver);
        stroke-width: 1.5;
        fill: none;
        transition: all 0.3s var(--ease-out-expo);
      }

      .upload-area:hover .upload-icon svg,
      .upload-area.dragging .upload-icon svg {
        stroke: var(--vermillion);
        transform: translateY(-4px);
      }

      .upload-text {
        font-family: var(--font-display);
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--paper);
        margin-bottom: 8px;
        text-align: center;
        letter-spacing: -0.01em;
      }

      .upload-subtext {
        font-family: var(--font-mono);
        font-size: 0.7rem;
        color: var(--ash);
        text-align: center;
        letter-spacing: 0.02em;
        max-width: 280px;
        line-height: 1.6;
      }

      #fileInput {
        display: none;
      }

      /* Preview container */
      .preview-container {
        display: none;
        flex-direction: column;
        gap: 20px;
        padding: 24px;
      }

      .image-wrapper {
        position: relative;
        background: var(--ink);
        padding: 12px;
        border: 1px solid var(--smoke);
      }

      .image-preview {
        width: 100%;
        max-height: 320px;
        object-fit: contain;
        display: block;
      }

      /* Film sprocket holes decoration */
      .image-wrapper::before,
      .image-wrapper::after {
        content: '';
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 8px;
        height: 80%;
        background-image: repeating-linear-gradient(
          180deg,
          var(--smoke) 0px,
          var(--smoke) 6px,
          transparent 6px,
          transparent 14px
        );
      }

      .image-wrapper::before {
        left: -16px;
      }

      .image-wrapper::after {
        right: -16px;
      }

      /* EXIF info panel */
      .exif-panel {
        background: var(--ink);
        border: 1px solid var(--smoke);
        padding: 16px;
        max-height: 160px;
        overflow-y: auto;
      }

      .exif-panel::-webkit-scrollbar {
        width: 4px;
      }

      .exif-panel::-webkit-scrollbar-track {
        background: var(--ink);
      }

      .exif-panel::-webkit-scrollbar-thumb {
        background: var(--smoke);
      }

      .exif-header {
        font-family: var(--font-mono);
        font-size: 0.65rem;
        color: var(--vermillion);
        text-transform: uppercase;
        letter-spacing: 0.1em;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .exif-header::before {
        content: '\26A0';
        font-size: 0.8rem;
      }

      .exif-list {
        list-style: none;
        font-family: var(--font-mono);
        font-size: 0.7rem;
        color: var(--silver);
        line-height: 1.8;
      }

      .exif-list li::before {
        content: '\203A';
        margin-right: 8px;
        color: var(--ash);
      }

      .exif-clean {
        color: var(--success);
      }

      .exif-clean .exif-header {
        color: var(--success);
      }

      .exif-clean .exif-header::before {
        content: '\2713';
      }

      /* Buttons */
      .button-row {
        display: flex;
        gap: 12px;
      }

      .btn {
        flex: 1;
        padding: 16px 24px;
        border: none;
        font-family: var(--font-display);
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: all 0.3s var(--ease-out-expo);
        position: relative;
        overflow: hidden;
      }

      .btn-primary {
        background: var(--vermillion);
        color: var(--paper);
      }

      .btn-primary:hover {
        background: #d12f23;
        transform: translateY(-2px);
        box-shadow: 0 8px 24px var(--vermillion-glow);
      }

      .btn-primary:active {
        transform: translateY(0);
      }

      .btn-secondary {
        background: transparent;
        color: var(--silver);
        border: 1px solid var(--smoke);
      }

      .btn-secondary:hover {
        border-color: var(--silver);
        color: var(--paper);
      }

      /* Status messages */
      .status {
        display: none;
        padding: 16px 20px;
        font-family: var(--font-mono);
        font-size: 0.75rem;
        text-align: center;
        letter-spacing: 0.02em;
        border: 1px solid;
        animation: slideUp 0.4s var(--ease-out-back);
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .status-success {
        background: var(--success-dim);
        color: var(--success);
        border-color: var(--success);
      }

      .status-error {
        background: rgba(230, 59, 46, 0.1);
        color: var(--vermillion);
        border-color: var(--vermillion);
      }

      .status-info {
        background: rgba(154, 154, 159, 0.1);
        color: var(--silver);
        border-color: var(--smoke);
      }

      /* Loading */
      .loading-indicator {
        display: none;
        padding: 20px;
        text-align: center;
        font-family: var(--font-mono);
        font-size: 0.75rem;
        color: var(--silver);
        letter-spacing: 0.02em;
      }

      .loading-indicator::before {
        content: '';
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid var(--smoke);
        border-top-color: var(--vermillion);
        border-radius: 50%;
        margin-right: 12px;
        vertical-align: middle;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Footer */
      .footer {
        padding: 24px 20px;
        text-align: center;
        border-top: 1px solid var(--smoke);
        margin-top: auto;
      }

      .footer-text {
        font-family: var(--font-mono);
        font-size: 0.65rem;
        color: var(--ash);
        letter-spacing: 0.05em;
        text-transform: uppercase;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .footer-text span {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .footer-dot {
        width: 4px;
        height: 4px;
        background: var(--ash);
        border-radius: 50%;
      }

      /* Privacy badge */
      .privacy-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 12px;
        background: var(--charcoal);
        border: 1px solid var(--smoke);
        font-family: var(--font-mono);
        font-size: 0.6rem;
        color: var(--silver);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin-top: 24px;
      }

      .privacy-badge svg {
        width: 12px;
        height: 12px;
        stroke: var(--success);
      }

      /* Documentation section - styled to match the main card theme */
      .docs {
        margin-top: 4px;
        padding: 20px 18px;
        background: var(--charcoal);
        border: 1px solid var(--smoke);
        position: relative;
      }

      /* Corner accents (smaller than the main card) */
      .docs::before,
      .docs::after {
        content: '';
        position: absolute;
        width: 18px;
        height: 18px;
        border-color: var(--vermillion);
        border-style: solid;
        opacity: 0.5;
        transition: opacity 0.3s ease;
        pointer-events: none;
      }

      .docs::before {
        top: -1px;
        left: -1px;
        border-width: 2px 0 0 2px;
      }

      .docs::after {
        bottom: -1px;
        right: -1px;
        border-width: 0 2px 2px 0;
      }

      .docs:hover::before,
      .docs:hover::after {
        opacity: 0.9;
      }

      /* Dashed inset for visual consistency with upload area */
      .docs .docs-inset {
        border: 1px dashed var(--ash);
        padding: 14px 14px;
        background: var(--ink);
      }

      .docs h2 {
        margin: 0 0 10px 0;
        font-size: 1.4rem;
        font-weight: 800;
        letter-spacing: -0.02em;
        color: var(--paper);
      }

      .docs p {
        font-family: var(--font-mono);
        font-size: 0.8rem;
        color: var(--silver);
        line-height: 1.8;
        margin: 8px 0 0 0;
      }

      .docs h3 {
        margin: 14px 0 6px 0;
        font-family: var(--font-mono);
        font-size: 0.65rem;
        color: var(--vermillion);
        text-transform: uppercase;
        letter-spacing: 0.1em;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .docs h3::before {
        content: '\203A';
        color: var(--ash);
        font-size: 0.8rem;
      }

      .docs ul {
        list-style: none;
        font-family: var(--font-mono);
        font-size: 0.75rem;
        color: var(--silver);
        line-height: 1.9;
        margin-top: 4px;
      }

      .docs li::before {
        content: '\203A';
        margin-right: 8px;
        color: var(--ash);
      }

      .docs strong {
        color: var(--paper);
        font-weight: 600;
      }

      .docs code {
        font-family: var(--font-mono);
        font-size: 0.95em;
        color: var(--paper);
      }

      /* Responsive */
      @media (max-width: 480px) {
        .container {
          padding: 24px 16px;
        }

        .logo {
          font-size: 2.2rem;
        }

        .upload-area {
          min-height: 200px;
          padding: 32px 24px;
        }

        .image-wrapper::before,
        .image-wrapper::after {
          display: none;
        }
      }

      /* Light mode adjustments */
      @media (prefers-color-scheme: light) {
        :root {
          --ink: #f5f2eb;
          --paper: #0a0a0b;
          --paper-dim: #1a1a1c;
          --charcoal: #ffffff;
          --smoke: #e8e4db;
          --ash: #9a9a9f;
          --silver: #6b6b70;
        }

        body::before {
          opacity: 0.02;
        }

        .bg-pattern {
          opacity: 0.02;
        }

        .card {
          box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <header class="header">
        <h1 class="logo">
          <span class="logo-main">EXIF</span>
          <span class="logo-accent">Cleaner</span>
        </h1>
        <p class="tagline">Strip metadata. Protect privacy.</p>
      </header>

      <main class="card">
        <div id="uploadContainer" class="upload-area">
          <div class="upload-icon">
            <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
              <rect x="8" y="12" width="48" height="40" rx="2"/>
              <circle cx="24" cy="28" r="6"/>
              <path d="M8 44 L24 32 L36 40 L48 28 L56 36"/>
              <path d="M32 4 L32 20 M24 12 L32 4 L40 12"/>
            </svg>
          </div>
          <p class="upload-text">Drop image or click to upload</p>
          <p class="upload-subtext">
            All processing happens locally in your browser.
            Nothing is uploaded to any server.
          </p>
          <input type="file" id="fileInput" accept="image/*" />
        </div>

        <div id="previewContainer" class="preview-container">
          <div class="image-wrapper">
            <img id="imagePreview" class="image-preview" src="" alt="Preview" />
          </div>

          <div id="exifInfo" class="exif-panel"></div>

          <div class="button-row">
            <button id="resetBtn" class="btn btn-secondary">&larr; Back</button>
            <button id="downloadBtn" class="btn btn-primary">Download Clean</button>
          </div>
        </div>
      </main>

      <div id="loadingIndicator" class="loading-indicator">
        Processing image...
      </div>

      <div id="statusMessage" class="status"></div>

      <div class="privacy-badge">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
          <polyline points="9 12 11 14 15 10"/>
        </svg>
        100% Client-side Processing
      </div>

      <!-- Documentation for how different formats are handled.
           This is user-facing guidance explaining when processing is lossless. -->
      <section class="docs" aria-label="Processing documentation">
        <div class="docs-inset">
          <h2>格式说明 / How We Clean Metadata</h2>
          <p>
            本工具会先读取图片的 EXIF/元数据并展示，然后生成一份“清理后的文件”供下载。
            不同格式的清理方式不同，是否会重新渲染（重编码）也不同：
          </p>

          <h3>JPEG / JPG（不会重新渲染）</h3>
          <ul>
            <li>我们直接在文件二进制层面移除元数据段（如 EXIF / XMP / IPTC）。</li>
            <li>像素数据不变，不经过 canvas 重编码，因此图片质量、分辨率、色彩不发生变化。</li>
            <li>结果仅丢失敏感元数据，文件体积通常会变小。</li>
          </ul>

          <p>在 JPEG 中会被移除的典型元数据包括（不限于）：</p>
          <ul>
            <li><strong>位置信息（GPS）</strong>：GPSLatitude / GPSLongitude / GPSAltitude / GPSDateStamp 等，可暴露拍摄地点与时间。</li>
            <li><strong>拍摄设备信息</strong>：Make / Model（相机/手机品牌型号）、SerialNumber / BodySerialNumber（序列号）。</li>
            <li><strong>镜头与拍摄参数</strong>：LensMake / LensModel / FocalLength / ExposureTime / FNumber / ISO 等。</li>
            <li><strong>时间信息</strong>：DateTimeOriginal / DateTimeDigitized / DateTime，可暴露拍摄时间线。</li>
            <li><strong>作者与版权</strong>：Artist / Copyright / OwnerName。</li>
            <li><strong>软件痕迹</strong>：Software / ProcessingSoftware / Adobe XMP 等编辑软件与工作流信息。</li>
            <li><strong>缩略图与预览</strong>：EXIF 内嵌缩略图（Thumbnail）及相关字段。</li>
          </ul>

          <h3>HEIC / HEIF（会重新渲染一次）</h3>
          <ul>
            <li>浏览器无法对 HEIC 做无损元数据移除，我们会先将其转换为 JPEG。</li>
            <li>转换过程等同于一次重编码，因此可能产生轻微质量变化。</li>
            <li>转换后我们仍会移除 JPEG 的元数据段。</li>
          </ul>

          <h3>PNG / WebP / 其他格式（会重新渲染）</h3>
          <ul>
            <li>这些格式在浏览器端缺乏可靠的无损元数据写入/删除能力。</li>
            <li>因此会通过 canvas 重新导出为 JPEG 来确保干净输出。</li>
            <li>这会导致一次重编码，可能改变质量/体积/格式（例如 PNG 会变为 JPEG）。</li>
          </ul>

          <p>
            如果你希望完全无损、只移除元数据，请优先使用 JPEG/JPG 格式图片。
          </p>
        </div>
      </section>
    </div>

    <footer class="footer">
      <p class="footer-text">
        <span>No tracking</span>
        <span class="footer-dot"></span>
        <span>No uploads</span>
        <span class="footer-dot"></span>
        <span>No logs</span>
      </p>
    </footer>

    <!-- Load the official exif-js library from CDN.
         This script defines a global `EXIF` object that we use below to read
         metadata from JPEG images before re-encoding them. -->
    <script src="https://unpkg.com/exif-js@2.3.0/exif.js"></script>

    <script>
    // --------------- App Code ---------------
    const fileInput = document.getElementById("fileInput");
    const uploadContainer = document.getElementById("uploadContainer");
    const previewContainer = document.getElementById("previewContainer");
    const imagePreview = document.getElementById("imagePreview");
    const exifInfo = document.getElementById("exifInfo");
    const downloadBtn = document.getElementById("downloadBtn");
    const resetBtn = document.getElementById("resetBtn");
    const statusMessage = document.getElementById("statusMessage");
    const loadingIndicator = document.getElementById("loadingIndicator");

    let originalFileName = "";
    let cleanedImageBlob = null;
    let hasExifData = false;
    let lastProcessWasLossless = false;
    let lastProcessNote = "";
    let lastRemovedCategories = [];

    // Setup event listeners
    uploadContainer.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", handleFileSelect);
    downloadBtn.addEventListener("click", downloadCleanedImage);
    resetBtn.addEventListener("click", resetApp);

    // Setup drag and drop
    ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
      uploadContainer.addEventListener(eventName, preventDefaults, false);
    });

    ["dragenter", "dragover"].forEach((eventName) => {
      uploadContainer.addEventListener(eventName, highlight, false);
    });

    ["dragleave", "drop"].forEach((eventName) => {
      uploadContainer.addEventListener(eventName, unhighlight, false);
    });

    uploadContainer.addEventListener("drop", handleDrop, false);

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight() {
      uploadContainer.classList.add("dragging");
    }

    function unhighlight() {
      uploadContainer.classList.remove("dragging");
    }

    function handleDrop(e) {
      const files = e.dataTransfer.files;
      if (files.length) {
        fileInput.files = files;
        handleFileSelect({ target: { files } });
      }
    }

    // --------------- HEIC to JPEG Converter ---------------
    const HEICConverter = (function () {
      const supportsOffscreenCanvas = typeof OffscreenCanvas !== "undefined";

      async function convertHEICToJPEG(heicBlob) {
        return new Promise(async (resolve, reject) => {
          try {
            const url = URL.createObjectURL(heicBlob);
            const img = document.createElement("img");

            img.onerror = function () {
              URL.revokeObjectURL(url);
              reject(
                new Error(
                  "Browser cannot decode HEIC format. Try converting to JPEG first.",
                ),
              );
            };

            img.onload = function () {
              URL.revokeObjectURL(url);

              const canvas = supportsOffscreenCanvas
                ? new OffscreenCanvas(img.width, img.height)
                : document.createElement("canvas");

              canvas.width = img.width;
              canvas.height = img.height;

              const ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0);

              if (supportsOffscreenCanvas) {
                canvas
                  .convertToBlob({ type: "image/jpeg", quality: 0.92 })
                  .then(resolve)
                  .catch(reject);
              } else {
                canvas.toBlob((blob) => resolve(blob), "image/jpeg", 0.92);
              }
            };

            img.src = url;
          } catch (error) {
            reject(error);
          }
        });
      }

      function isHEICImage(file) {
        return (
          file.type === "image/heic" ||
          file.type === "image/heif" ||
          file.name.toLowerCase().endsWith(".heic") ||
          file.name.toLowerCase().endsWith(".heif")
        );
      }

      return {
        convertHEICToJPEG,
        isHEICImage,
      };
    })();

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (!file) return;

      if (!file.type.match("image.*") && !HEICConverter.isHEICImage(file)) {
        showStatus("Please select an image file.", "error", { autoHideMs: null });
        return;
      }

      originalFileName = file.name;
      showLoading(true);

      if (HEICConverter.isHEICImage(file)) {
        // Keep this status visible until conversion finishes.
        showStatus("Converting HEIC image...", "info", { autoHideMs: null });

        HEICConverter.convertHEICToJPEG(file)
          .then((convertedBlob) => {
            // HEIC conversion already re-encodes the image once.
            processImage(convertedBlob, originalFileName, { fromHeic: true });
          })
          .catch((err) => {
            console.error("HEIC conversion error:", err);
            showStatus(
              "Error converting HEIC image. Your browser may not support HEIC format natively.",
              "error",
              { autoHideMs: null },
            );
            showLoading(false);
          });
      } else {
        processImage(file, originalFileName, { fromHeic: false });
      }
    }

    // Read a Blob/File as DataURL.
    function readAsDataURL(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
      });
    }

    // Read a Blob/File as ArrayBuffer.
    function readAsArrayBuffer(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(blob);
      });
    }

    // Losslessly strip metadata segments from a JPEG file.
    // This removes APP1 (EXIF/XMP), APP13 (IPTC/Photoshop), and COM (comments)
    // without touching the scan data, so pixels/quality stay identical.
    function stripJpegMetadata(arrayBuffer) {
      const bytes = new Uint8Array(arrayBuffer);
      if (bytes.length < 4 || bytes[0] !== 0xff || bytes[1] !== 0xd8) {
        return arrayBuffer; // Not a JPEG.
      }

      const chunks = [];
      chunks.push(bytes.slice(0, 2)); // SOI

      let offset = 2;
      while (offset < bytes.length) {
        if (bytes[offset] !== 0xff) {
          // Unexpected data; copy the rest and stop.
          chunks.push(bytes.slice(offset));
          break;
        }

        const marker = bytes[offset + 1];

        // Start of Scan: copy scan data to end, then stop parsing.
        if (marker === 0xda) {
          chunks.push(bytes.slice(offset));
          break;
        }

        // Standalone markers (no length field).
        if (
          marker === 0x01 ||
          (marker >= 0xd0 && marker <= 0xd7) ||
          marker === 0xd8 ||
          marker === 0xd9
        ) {
          chunks.push(bytes.slice(offset, offset + 2));
          offset += 2;
          continue;
        }

        if (offset + 4 > bytes.length) {
          chunks.push(bytes.slice(offset));
          break;
        }

        const length = (bytes[offset + 2] << 8) | bytes[offset + 3];
        const segmentEnd = offset + 2 + length;

        if (segmentEnd > bytes.length || length < 2) {
          chunks.push(bytes.slice(offset));
          break;
        }

        const shouldRemove =
          marker === 0xe1 || // APP1: EXIF/XMP
          marker === 0xed || // APP13: IPTC/Photoshop
          marker === 0xfe;   // COM: comment

        if (!shouldRemove) {
          chunks.push(bytes.slice(offset, segmentEnd));
        }

        offset = segmentEnd;
      }

      const totalLength = chunks.reduce((sum, c) => sum + c.length, 0);
      const out = new Uint8Array(totalLength);
      let pos = 0;
      for (const c of chunks) {
        out.set(c, pos);
        pos += c.length;
      }
      return out.buffer;
    }

    // Helper function to safely escape text for display
    function escapeText(text) {
      if (text === null || text === undefined) return '';
      return String(text);
    }

    // Identify high-level metadata categories that are considered sensitive
    // and will be removed from the output file.
    function getRemovedCategories(allTags) {
      const categories = [];

      // GPS / location
      if (
        allTags.GPSLatitude ||
        allTags.GPSLongitude ||
        allTags.GPSAltitude ||
        allTags.GPSDateStamp ||
        allTags.GPSLatitudeRef ||
        allTags.GPSLongitudeRef
      ) {
        categories.push("GPS location data");
      }

      // Camera / device identity
      if (allTags.Make || allTags.Model || allTags.SerialNumber || allTags.BodySerialNumber) {
        categories.push("Camera/device identity");
      }

      // Lens & exposure / shooting parameters
      const lensOrExposureKeys = [
        "LensMake",
        "LensModel",
        "FocalLength",
        "ExposureTime",
        "FNumber",
        "ISOSpeedRatings",
        "ShutterSpeedValue",
        "ApertureValue",
        "ExposureBias",
        "Flash",
        "FocalLengthIn35mmFilm",
      ];
      if (lensOrExposureKeys.some((k) => allTags[k] !== undefined)) {
        categories.push("Lens & shooting parameters");
      }

      // Timestamps
      if (allTags.DateTime || allTags.DateTimeOriginal || allTags.DateTimeDigitized) {
        categories.push("Capture timestamps");
      }

      // Author / copyright
      if (allTags.Artist || allTags.Copyright || allTags.OwnerName) {
        categories.push("Author/copyright");
      }

      // Software / workflow traces
      if (allTags.Software || allTags.ProcessingSoftware) {
        categories.push("Software/workflow traces");
      }

      // Embedded thumbnails / previews
      if (allTags.ThumbnailImage || allTags.JPEGInterchangeFormat) {
        categories.push("Embedded thumbnails");
      }

      return categories;
    }

    // Build EXIF info panel using safe DOM methods
    function buildExifPanel(allTags, hasData) {
      // Clear existing content
      while (exifInfo.firstChild) {
        exifInfo.removeChild(exifInfo.firstChild);
      }

      const header = document.createElement('div');
      header.className = 'exif-header';

      const list = document.createElement('ul');
      list.className = 'exif-list';

      if (hasData) {
        header.textContent = 'Metadata detected — will be removed';
        exifInfo.classList.remove('exif-clean');

        const items = [];

        // High-level sensitive categories that will be removed.
        lastRemovedCategories = getRemovedCategories(allTags);
        if (lastRemovedCategories.length) {
          lastRemovedCategories.forEach((c) => items.push("Will remove: " + c));
        }

        // Show a couple of friendly examples without dumping raw tags.
        if (allTags.Make || allTags.Model) {
          const cameraInfo =
            escapeText(allTags.Make || "") + " " + escapeText(allTags.Model || "");
          items.push("Detected camera: " + cameraInfo.trim());
        }
        if (allTags.DateTime || allTags.DateTimeOriginal) {
          items.push(
            "Detected time: " +
              escapeText(allTags.DateTimeOriginal || allTags.DateTime),
          );
        }

        const tagCount = Object.keys(allTags).length;
        items.push(tagCount + " total metadata fields");

        items.forEach(function (itemText) {
          const li = document.createElement('li');
          li.textContent = itemText;
          list.appendChild(li);
        });
      } else {
        header.textContent = 'No metadata found';
        exifInfo.classList.add('exif-clean');
        lastRemovedCategories = [];

        const li = document.createElement('li');
        li.textContent = 'Image will be re-processed to ensure clean output';
        list.appendChild(li);
      }

      exifInfo.appendChild(header);
      exifInfo.appendChild(list);
    }

    async function processImage(file, originalName, options) {
      const fromHeic = options && options.fromHeic;
      lastProcessWasLossless = false;
      lastProcessNote = "";

      const isJpeg =
        (file.type && file.type.toLowerCase() === "image/jpeg") ||
        /\.jpe?g$/i.test(originalName);

      try {
        // Read DataURL for preview/EXIF and ArrayBuffer for lossless JPEG stripping.
        const [dataUrl, arrayBuffer] = await Promise.all([
          readAsDataURL(file),
          readAsArrayBuffer(file),
        ]);

        imagePreview.src = dataUrl;

        const img = new Image();
        img.onload = function () {
          // The global EXIF object is provided by the official exif-js CDN script.
          // If it did not load (offline / blocked CDN), fall back to "no metadata"
          // so the tool still works instead of crashing.
          if (!window.EXIF || typeof window.EXIF.getData !== "function") {
            hasExifData = false;
            buildExifPanel({}, false);
            if (isJpeg) {
              const stripped = stripJpegMetadata(arrayBuffer);
              cleanedImageBlob = new Blob([stripped], { type: "image/jpeg" });
              lastProcessWasLossless = !fromHeic;
              lastProcessNote = fromHeic
                ? "HEIC was converted to JPEG first"
                : "Lossless JPEG metadata strip";
              finalizeClean();
            } else {
              cleanImage(img);
            }
            return;
          }

          EXIF.getData(img, function () {
            const allTags = EXIF.getAllTags(this);
            hasExifData = Object.keys(allTags).length > 0;

            // Build EXIF panel using safe DOM methods
            buildExifPanel(allTags, hasExifData);

            // Show a persistent pre-clean status so users understand what will be removed.
            if (hasExifData && lastRemovedCategories.length) {
              showStatus(
                "Metadata detected — removing: " +
                  lastRemovedCategories.join(", ") +
                  "...",
                "info",
                { autoHideMs: null },
              );
            } else if (!hasExifData) {
              showStatus("No metadata detected — producing clean copy...", "info", {
                autoHideMs: null,
              });
            }

            if (isJpeg) {
              const stripped = stripJpegMetadata(arrayBuffer);
              cleanedImageBlob = new Blob([stripped], { type: "image/jpeg" });
              lastProcessWasLossless = !fromHeic;
              lastProcessNote = fromHeic
                ? "HEIC was converted to JPEG first"
                : "Lossless JPEG metadata strip";
              finalizeClean();
            } else {
              cleanImage(img);
            }
          });
        };
        img.src = dataUrl;
      } catch (error) {
        console.error("Process image error:", error);
        showStatus("Failed to read image.", "error", { autoHideMs: null });
        showLoading(false);
      }
    }

    function finalizeClean() {
      uploadContainer.style.display = "none";
      previewContainer.style.display = "flex";

      if (lastProcessWasLossless) {
        const details = lastRemovedCategories.length
          ? " Removed: " + lastRemovedCategories.join(", ") + "."
          : "";
        showStatus("Metadata stripped (lossless JPEG)." + details, "success", { autoHideMs: null });
      } else if (lastProcessNote) {
        const details = lastRemovedCategories.length
          ? " Removed: " + lastRemovedCategories.join(", ") + "."
          : "";
        showStatus(
          "Metadata stripped — image was re-encoded." + details,
          "info",
          { autoHideMs: null },
        );
      } else if (hasExifData) {
        const details = lastRemovedCategories.length
          ? " Removed: " + lastRemovedCategories.join(", ") + "."
          : "";
        showStatus("Metadata stripped successfully." + details, "success", { autoHideMs: null });
      } else {
        showStatus("Image processed — ready for download", "info", { autoHideMs: null });
      }

      showLoading(false);
    }

    function cleanImage(image) {
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;

      const ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0);

      canvas.toBlob(
        function (blob) {
          cleanedImageBlob = blob;
          lastProcessWasLossless = false;
          lastProcessNote = "Canvas re-encode";
          finalizeClean();
        },
        "image/jpeg",
        0.92,
      );
    }

    function downloadCleanedImage() {
      if (!cleanedImageBlob) {
        showStatus("No processed image available.", "error", { autoHideMs: null });
        return;
      }

      const filenameParts = originalFileName.split(".");
      const extension = filenameParts.pop().toLowerCase();
      const basename = filenameParts.join(".");

      const newExtension =
        extension === "heic" || extension === "heif" ? "jpg" : extension;
      const cleanFilename = basename + "_clean." + newExtension;

      const url = URL.createObjectURL(cleanedImageBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = cleanFilename;
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();

      setTimeout(function() {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);

      // Keep the download status visible until another status replaces it.
      showStatus("Download started", "success", { autoHideMs: null });
    }

    function resetApp() {
      uploadContainer.style.display = "flex";
      previewContainer.style.display = "none";
      imagePreview.src = "";
      // Clear exif info safely
      while (exifInfo.firstChild) {
        exifInfo.removeChild(exifInfo.firstChild);
      }
      exifInfo.classList.remove('exif-clean');
      statusMessage.style.display = "none";
      fileInput.value = "";
      cleanedImageBlob = null;
      originalFileName = "";
      hasExifData = false;
      lastProcessWasLossless = false;
      lastProcessNote = "";
    }

    function showStatus(message, type, options) {
      type = type || "info";
      statusMessage.textContent = message;
      statusMessage.className = "status";
      statusMessage.classList.add("status-" + type);
      statusMessage.style.display = "block";

      // This tool processes one image at a time, so status messages are meant
      // to be persistent. By default we do not auto-hide; callers can opt in
      // to auto-hiding by passing a number of milliseconds.
      const autoHideMs =
        options && Object.prototype.hasOwnProperty.call(options, "autoHideMs")
          ? options.autoHideMs
          : null;

      if (autoHideMs !== null && autoHideMs !== undefined) {
        setTimeout(function () {
          statusMessage.style.display = "none";
        }, autoHideMs);
      }
    }

    function showLoading(show) {
      loadingIndicator.style.display = show ? "block" : "none";
    }
    </script>
  </body>
</html>
